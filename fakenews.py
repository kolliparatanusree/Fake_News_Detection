# -*- coding: utf-8 -*-
"""Fakenews.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12c9Ktn2C_RTgME_hMNRWEZChQLD-RiET
"""

# Commented out IPython magic to ensure Python compatibility.

import pandas as pd
import numpy as np
import re
from matplotlib import pyplot as plt
import seaborn as sns
# %matplotlib inline

import nltk
from nltk.corpus import stopwords
from nltk.stem.porter import PorterStemmer

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_extraction.text import TfidfTransformer

from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.metrics import confusion_matrix, classification_report, roc_curve, auc, RocCurveDisplay
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.naive_bayes import MultinomialNB



import warnings
warnings.filterwarnings("ignore")

nltk.download('stopwords')

print (stopwords.words('english'))

train_news = pd.read_csv('/content/train.csv')
train_news.head()

test_news = pd.read_csv('/content/test.csv')
test_news.head()

train_news.shape

test_news.shape

train_news.isnull().sum()

test_news.isnull().sum()

train_news = train_news.fillna(' ')
test_news = test_news.fillna(' ')

train_news['content'] = train_news['author']+' '+train_news['title']
test_news['content'] = test_news['author']+' '+test_news['title']

print(train_news['content'])

print(test_news['content'])

port_stem = PorterStemmer()

def stemming(content):
    stemmed_content = re.sub('^a-zA-Z', ' ', content)
    stemmed_content = stemmed_content.lower()
    stemmed_content = stemmed_content.split()
    stemmed_content = [port_stem.stem(word) for word in stemmed_content if not word in stopwords.words('english')]
    stemmed_content = ' '.join(stemmed_content)
    return stemmed_content

train_news['content'] = train_news['content'].apply(stemming)
test_news['content'] = test_news['content'].apply(stemming)

print(train_news['content'])

print(test_news['content'])

X = train_news['content'].values
Y = train_news['label'].values

print(X)

print(Y)

transformer = TfidfTransformer(smooth_idf=False)
count_vectorizer = CountVectorizer(ngram_range=(1, 2))
counts = count_vectorizer.fit_transform(train_news['content'].values)
X = transformer.fit_transform(counts)

Y = train_news['label'].values
test_counts = count_vectorizer.transform(test_news['content'].values)
test_tfidf = transformer.fit_transform(test_counts)

print(X)

X.shape

print(test_tfidf)

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, stratify=Y, random_state=42)

print(f"Number of Training dataset: {X_train.shape[0]}\nNumber of Testing dataset: {X_test.shape[0]}")

def kfolds(model, model_name):
    model = cross_val_score(model, X,Y, cv=10)
    model_score = np.average(model)
    print(f"{model_name} score on cross validation: {model_score * 100}%")

def train(model, model_name):
    model.fit(X_train, Y_train)
    model_train_score = model.score(X_train, Y_train)
    model_test_score = model.score(X_test, Y_test)
    print(f"{model_name} model score on Training data: {model_train_score * 100}%\n{model_name} model score on Testing data: {model_test_score * 100}%")

def conf_matrix(model):
    Y_pred = model.predict(X_test)
    cm = confusion_matrix(Y_test, Y_pred)
    plt.figure(figsize=(8,5))
    sns.heatmap(cm, annot=True, fmt='.2f');

def class_report(model):
    Y_pred = model.predict(X_test)
    print(classification_report(Y_test, Y_pred))

def roc(model, model_name):
    Y_pred_svm = model.decision_function(X_test)
    svm_fpr, svm_tpr, _ = roc_curve(Y_test, Y_pred_svm)
    auc_svm = auc(svm_fpr, svm_tpr)
    plt.figure(figsize=(5, 5), dpi=100)
    plt.plot(svm_fpr, svm_tpr, color="darkorange", label=f'{model_name} (auc = %0.3f)' % auc_svm)
    plt.plot([0, 1], [0, 1], color="navy", lw=2, linestyle="--")
    plt.xlabel('False Positive Rate -->')
    plt.ylabel('True Positive Rate -->')
    plt.legend()
    plt.show()

log_model = LogisticRegression()
train(log_model, "Logistic Regression")

conf_matrix(log_model)

class_report(log_model)

roc(log_model, 'Logistic_Regression')

#svm model
svm_model = SVC()
train(svm_model, 'SV_classifier')

conf_matrix(svm_model)

class_report(svm_model)

roc(svm_model, 'SV_classifier')

dt_model = DecisionTreeClassifier()
kfolds(dt_model, "Decision_Tree")
train(dt_model, "Decision_Tree")

conf_matrix(dt_model)

class_report(dt_model)

rf_model = RandomForestClassifier()
train(rf_model, "Random_Forest")

conf_matrix(rf_model)

class_report(rf_model)

# Make predictions --> Logistic Regression
predictions = log_model.predict(test_tfidf)
# Submissions
test_ID = test_news.id
submission = pd.DataFrame({'id' : test_ID, 'label' : predictions})

submission.head()

submission.to_csv("./Logistic Regression.csv", index=False) # Convert the submissions to .csv

# Make predictions -->
predictions = dt_model.predict(test_tfidf)
# Submissions
test_ID = test_news.id
dt_submission = pd.DataFrame({'id' : test_ID, 'label' : predictions})

dt_submission.head()

dt_submission.to_csv("./Decision Tree.csv", index=False) # Convert the submissions to .csv

